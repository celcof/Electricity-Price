library(ggpubr)
library(car)
library(eurostat)
library(HDCI)
library(caret)
library(scales)
library(glmnet)
library(corrplot)
library(wbstats)
library(lmtest)
library(sandwich)
library(robustbase)
D <- read.csv("DAT.csv")
LM <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR, D)
summary(LM)
for (row in 1:nrow(D)) {
if (as.character(D[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "BG", "ES", "LU", "RO", "CZ", "FR", "HU", "SI", "DK", "HR", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "SE", "IE", "LV", "PL", "UK")) {
D$EU[row] <- 1
}
else { D$EU[row] <- 0 }
}
LMe <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
summary(LMe)
DP <- D
for (row in 1:nrow(DP)) {
if (as.character(DP[row, "geo"]) %in% c("BG", "RO", "CZ", "HU", "HR", "SE", "DK", "PL", "UK")) {
DP$EU[row] <- "EU"
}
else if (as.character(DP[row, "geo"]) %in% c("NO", "IS", "LI")) {
DP$EU[row] <- "EFTA"
}
else if (as.character(DP[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "ES", "LU", "FR", "SI", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "IE", "LV")){
DP$EU[row] <- "EA"
}
}
rm(row)
DP$EU <- as.factor(DP$EU)
LMeP <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + geo, DP)
summary(LMeP)
par(mfrow = c(2, 2))
plot(LMeP)
D[c(956,996),]
mean(LMeP$residuals)
lawstat::runs.test(LMeP$residuals)
vif(LMeP)
plot(LMeP,1)
S <- DP
U <- caret::BoxCoxTrans(S$PRI)
S <- cbind(S, nP=predict(U, S$PRI))
LMeB <- lm(nP ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, S)
bptest(LMeB)
rm(S, U)
DP$resi <- LMeP$residuals
LMeR <- lm(log(resi^2) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
DP$varFunc <- exp(LMeR$fitted.values)
LMgls <- lm(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, weights = 1/sqrt(varFunc), DP)
summary(LMgls)
plot(LMgls)
bptest(LMgls)
lmrobfit <- lmrob(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
bptest(lmrobfit)
rm(lmrobfit)
ggdensity(log(DP$PRI), main = "Density function PRI")
qqnorm(residuals(LMgls), ylab="Residuals")
qqline(residuals(LMgls))
hist(residuals(LMgls))
shapiro.test(residuals(LMgls))
library(leaps)
LM3 <- regsubsets(sqrt(PRI) ~ DEP + CON + GDP + OIL + REN + EMI + MAR + geo + NUC + CRI, D, nvmax = 36)
bptest(LMeP)
lmrobfit <- rlm(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
library(MASS)
lmrobfit <- rlm(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
summary(lmrobfit)
bptest(lmrobfit)
shapiro.test(residuals(lmrobfit))
library(quantreg)
lmrobfit <- rq(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- lmrob(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
library(quantreg)
lmrobfit <- rq(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- rq(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- lm(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- rq(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- rq(PRI ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- rq(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
lmrobfit <- rq(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
lmrobfit <- rq.formula(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
library(quantreg)
lmrobfit <- rq.formula(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
shapiro.test(residuals(lmrobfit))
lmrobfit <- rq.formula(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
lmrobfit <- rq.formula(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data = DP)
lmrobfit <- rq(DEP ~ log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data = DP)
lmrobfit <- rq(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data = DP)
shapiro.test(residuals(lmrobfit))
summary(lmrobfit)
plot(lmrobfit)
bptest(lmrobfit)
library(lqs)
install.packages("lqs")
lmrobfit <- lqs(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data = DP)
bptest(lmrobfit)
shapiro.test(residuals(lmrobfit))
summary(lmrobfit)
lmrobfit$coefficients
lmrobfit$model
lmrobfit <- Itsreg(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data = DP)
lmrobfit <- ltsreg(log(PRI) ~ DEP + log(GAS) + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data = DP)
bptest(lmrobfit)
shapiro.test(residuals(lmrobfit))
boxcox(LMeR)
boxcox(LMeP)
boxcox(LMeB)
boxcox(LMe)
LME <- lm(PRI ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
boxcox(LME)
boxcox(LME, plotit=T)
boxcox (LME, lambda=seq (0.0, 0.5, by=0.05), plotit=T)
boxcox (LME, lambda=seq (0.2, 0.5, by=0.05), plotit=T)
tLM <- regsubsets(log(PRI) ~ (log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR)^2 + EU, DP, subset=train, nvmax = 30, really.big = T)
library(ggpubr)
library(car)
library(eurostat)
library(HDCI)
library(caret)
library(scales)
library(glmnet)
library(corrplot)
library(wbstats)
library(lmtest)
library(sandwich)
library(robustbase)
D <- read.csv("DAT.csv")
LM <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR, D)
summary(LM)
for (row in 1:nrow(D)) {
if (as.character(D[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "BG", "ES", "LU", "RO", "CZ", "FR", "HU", "SI", "DK", "HR", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "SE", "IE", "LV", "PL", "UK")) {
D$EU[row] <- 1
}
else { D$EU[row] <- 0 }
}
LMe <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
summary(LMe)
DP <- D
for (row in 1:nrow(DP)) {
if (as.character(DP[row, "geo"]) %in% c("BG", "RO", "CZ", "HU", "HR", "SE", "DK", "PL", "UK")) {
DP$EU[row] <- "EU"
}
else if (as.character(DP[row, "geo"]) %in% c("NO", "IS", "LI")) {
DP$EU[row] <- "EFTA"
}
else if (as.character(DP[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "ES", "LU", "FR", "SI", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "IE", "LV")){
DP$EU[row] <- "EA"
}
}
rm(row)
DP$EU <- as.factor(DP$EU)
LMeP <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
summary(LMeP)
par(mfrow = c(2, 2))
plot(LMeP)
D[c(956,996),]
lawstat::runs.test(LMeP$residuals)
vif(LMeP)
plot(LMeP,1)
S <- DP
U <- caret::BoxCoxTrans(S$PRI)
S <- cbind(S, nP=predict(U, S$PRI))
LMeB <- lm(nP ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, S)
bptest(LMeB)
rm(S, U)
DP$resi <- LMeP$residuals
LMeR <- lm(log(resi^2) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
DP$varFunc <- exp(LMeR$fitted.values)
LMgls <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, weights = 1/sqrt(varFunc), DP)
summary(LMgls)
rm(LMeR)
print("Coefficients LM")
coef(LMeP)
print("Coefficients weighted regressions")
coef(LMgls)
library(leaps)
LM3 <- regsubsets(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP, nvmax = 12)
which.max(summary(LM3)$adjr2)
which.min(summary(LM3)$bic)
which.min(summary(LM3)$cp)
train <- (DP$time < 2015)
test <- (!train)
tLM <- regsubsets(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP, subset=train, nvmax = 11)
test.mat <- model.matrix(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data=DP[test,])
val.errors <- rep(NA, 11)
for (i in 1:11){
coefi <- coef(tLM, id=i)
pred <- test.mat[,names(coefi)] %*% coefi
val.errors[i] <- mean(abs(DP$PRI[test] - exp(pred)))
}
which.min(val.errors)
val.errors[which.min(val.errors)]
coef(tLM, which.min(val.errors))
x <- model.matrix(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)[,-1]
y <- DP$PRI
set.seed(35)
ridge <- cv.glmnet(x[train,], log(y[train]), alpha=0, standardize=T)
bestlam <- min(ridge$lambda)
ridge.pred <- predict(ridge, s=bestlam, newx=x[test,])
mean(abs(exp(ridge.pred) - y[test]))
predict(ridge, type="coefficients", s=bestlam)
lasso.mod <- glmnet(x[train,], log(y[train]), alpha=1)
plot(lasso.mod)
set.seed(35)
cv.out <- cv.glmnet(x[train,], sqrt(y[train]), alpha=1)
bestlam <- cv.out$lambda.min
pred <- predict(lasso.mod, s=bestlam, newx=x[test,])
mean(abs(exp(pred) - y[test]))
C <- as.vector(coef(cv.out, bestlam))
length(C[C != 0])
set.seed(35)
obj.escv <- escv.glmnet(x[train,], sqrt(y[train]))
obj <- Lasso(x[train,], sqrt(y[train]), lambda = obj.escv$lambda.cv)
pred <- mypredict(obj, newx = x[test,])
mean(abs(exp(pred) - y[test]))
tLM <- regsubsets(log(PRI) ~ (log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR)^2 + EU, DP, subset=train, nvmax = 30, really.big = T)
test.mat <- model.matrix((log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR)^2 + EU, data=DP[test,])
library(ggpubr)
library(car)
library(eurostat)
library(HDCI)
library(caret)
library(scales)
library(glmnet)
library(corrplot)
library(wbstats)
library(lmtest)
library(sandwich)
library(robustbase)
D <- read.csv("DAT.csv")
LM <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR, D)
summary(LM)
for (row in 1:nrow(D)) {
if (as.character(D[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "BG", "ES", "LU", "RO", "CZ", "FR", "HU", "SI", "DK", "HR", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "SE", "IE", "LV", "PL", "UK")) {
D$EU[row] <- 1
}
else { D$EU[row] <- 0 }
}
LMe <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
summary(LMe)
DP <- D
for (row in 1:nrow(DP)) {
if (as.character(DP[row, "geo"]) %in% c("BG", "RO", "CZ", "HU", "HR", "SE", "DK", "PL", "UK")) {
DP$EU[row] <- "EU"
}
else if (as.character(DP[row, "geo"]) %in% c("NO", "IS", "LI")) {
DP$EU[row] <- "EFTA"
}
else if (as.character(DP[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "ES", "LU", "FR", "SI", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "IE", "LV")){
DP$EU[row] <- "EA"
}
}
rm(row)
DP$EU <- as.factor(DP$EU)
LMeP <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
summary(LMeP)
par(mfrow = c(2, 2))
plot(LMeP)
D[c(956,996),]
lawstat::runs.test(LMeP$residuals)
vif(LMeP)
plot(LMeP,1)
S <- DP
U <- caret::BoxCoxTrans(S$PRI)
S <- cbind(S, nP=predict(U, S$PRI))
LMeB <- lm(nP ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, S)
bptest(LMeB)
rm(S, U)
DP$resi <- LMeP$residuals
LMeR <- lm(log(resi^2) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
DP$varFunc <- exp(LMeR$fitted.values)
LMgls <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, weights = 1/sqrt(varFunc), DP)
summary(LMgls)
rm(LMeR)
print("Coefficients LM")
coef(LMeP)
print("Coefficients weighted regressions")
coef(LMgls)
library(leaps)
LM3 <- regsubsets(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP, nvmax = 12)
which.max(summary(LM3)$adjr2)
which.min(summary(LM3)$bic)
which.min(summary(LM3)$cp)
train <- (DP$time < 2015)
test <- (!train)
tLM <- regsubsets(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP, subset=train, nvmax = 11)
test.mat <- model.matrix(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data=DP[test,])
val.errors <- rep(NA, 11)
for (i in 1:11){
coefi <- coef(tLM, id=i)
pred <- test.mat[,names(coefi)] %*% coefi
val.errors[i] <- mean(abs(DP$PRI[test] - exp(pred)))
}
which.min(val.errors)
val.errors[which.min(val.errors)]
coef(tLM, which.min(val.errors))
x <- model.matrix(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)[,-1]
y <- DP$PRI
set.seed(35)
ridge <- cv.glmnet(x[train,], log(y[train]), alpha=0, standardize=T)
bestlam <- min(ridge$lambda)
ridge.pred <- predict(ridge, s=bestlam, newx=x[test,])
mean(abs(exp(ridge.pred) - y[test]))
predict(ridge, type="coefficients", s=bestlam)
lasso.mod <- glmnet(x[train,], log(y[train]), alpha=1)
plot(lasso.mod)
set.seed(35)
cv.out <- cv.glmnet(x[train,], sqrt(y[train]), alpha=1)
bestlam <- cv.out$lambda.min
pred <- predict(lasso.mod, s=bestlam, newx=x[test,])
mean(abs(exp(pred) - y[test]))
C <- as.vector(coef(cv.out, bestlam))
length(C[C != 0])
set.seed(35)
obj.escv <- escv.glmnet(x[train,], sqrt(y[train]))
obj <- Lasso(x[train,], sqrt(y[train]), lambda = obj.escv$lambda.cv)
pred <- mypredict(obj, newx = x[test,])
mean(abs(exp(pred) - y[test]))
tLM <- regsubsets(log(PRI) ~ (log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR)^2 + EU, DP, subset=train, nvmax = 30, really.big = T)
test.mat <- model.matrix(log(PRI) ~ (log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR)^2 + EU, data=DP[test,])
val.errors <- rep(NA, 30)
for (i in 1:30){
coefi <- coef(tLM, id=i)
pred <- test.mat[,names(coefi)] %*% coefi
val.errors[i] <- mean(abs(DP$PRI[test] - exp(pred)))
}
which.min(val.errors)
val.errors[which.min(val.errors)]
coef(tLM, which.min(val.errors))
x <- model.matrix(log(PRI) ~ poly(log(GAS),2) + poly(DEP,2) + poly(log(CON),2) + poly(INF,2) + poly(REN,2) + poly(log(GDP)) + poly(log(OIL),2) + poly(MAR,2)^2 + EU, DP)[,-1]
lasso.mod <- glmnet(x[train,], log(y[train]), alpha=1)
set.seed(35)
cv.out <- cv.glmnet(x[train,], sqrt(y[train]), alpha=1)
bestlam <- cv.out$lambda.min
pred <- predict(lasso.mod, s=bestlam, newx=x[test,])
mean(abs(exp(pred) - y[test]))
library(ggpubr)
library(car)
library(eurostat)
library(HDCI)
library(caret)
library(scales)
library(glmnet)
library(corrplot)
library(wbstats)
library(lmtest)
library(sandwich)
library(robustbase)
D <- read.csv("DAT.csv")
LM <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR, D)
summary(LM)
for (row in 1:nrow(D)) {
if (as.character(D[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "BG", "ES", "LU", "RO", "CZ", "FR", "HU", "SI", "DK", "HR", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "SE", "IE", "LV", "PL", "UK")) {
D$EU[row] <- 1
}
else { D$EU[row] <- 0 }
}
LMe <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, D)
summary(LMe)
DP <- D
for (row in 1:nrow(DP)) {
if (as.character(DP[row, "geo"]) %in% c("BG", "RO", "CZ", "HU", "HR", "SE", "DK", "PL", "UK")) {
DP$EU[row] <- "EU"
}
else if (as.character(DP[row, "geo"]) %in% c("NO", "IS", "LI")) {
DP$EU[row] <- "EFTA"
}
else if (as.character(DP[row, "geo"]) %in% c("BE", "EL", "LT", "PT", "ES", "LU", "FR", "SI", "MT", "SK", "DE", "IT", "NL", "FI", "EE", "CY", "AT", "IE", "LV")){
DP$EU[row] <- "EA"
}
}
rm(row)
DP$EU <- as.factor(DP$EU)
LMeP <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
summary(LMeP)
par(mfrow = c(2, 2))
plot(LMeP)
D[c(956,996),]
lawstat::runs.test(LMeP$residuals)
vif(LMeP)
plot(LMeP,1)
S <- DP
U <- caret::BoxCoxTrans(S$PRI)
S <- cbind(S, nP=predict(U, S$PRI))
LMeB <- lm(nP ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, S)
bptest(LMeB)
rm(S, U)
DP$resi <- LMeP$residuals
LMeR <- lm(log(resi^2) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)
DP$varFunc <- exp(LMeR$fitted.values)
LMgls <- lm(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, weights = 1/sqrt(varFunc), DP)
summary(LMgls)
rm(LMeR)
print("Coefficients LM")
coef(LMeP)
print("Coefficients weighted regressions")
coef(LMgls)
library(leaps)
LM3 <- regsubsets(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP, nvmax = 12)
which.max(summary(LM3)$adjr2)
which.min(summary(LM3)$bic)
which.min(summary(LM3)$cp)
train <- (DP$time < 2015)
test <- (!train)
tLM <- regsubsets(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP, subset=train, nvmax = 11)
test.mat <- model.matrix(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, data=DP[test,])
val.errors <- rep(NA, 11)
for (i in 1:11){
coefi <- coef(tLM, id=i)
pred <- test.mat[,names(coefi)] %*% coefi
val.errors[i] <- mean(abs(DP$PRI[test] - exp(pred)))
}
which.min(val.errors)
val.errors[which.min(val.errors)]
coef(tLM, which.min(val.errors))
x <- model.matrix(log(PRI) ~ log(GAS) + DEP + log(CON) + INF + REN + log(GDP) + log(OIL) + MAR + EU, DP)[,-1]
y <- DP$PRI
set.seed(35)
ridge <- cv.glmnet(x[train,], log(y[train]), alpha=0, standardize=T)
bestlam <- min(ridge$lambda)
ridge.pred <- predict(ridge, s=bestlam, newx=x[test,])
mean(abs(exp(ridge.pred) - y[test]))
predict(ridge, type="coefficients", s=bestlam)
lasso.mod <- glmnet(x[train,], log(y[train]), alpha=1)
plot(lasso.mod)
set.seed(35)
cv.out <- cv.glmnet(x[train,], sqrt(y[train]), alpha=1)
bestlam <- cv.out$lambda.min
pred <- predict(lasso.mod, s=bestlam, newx=x[test,])
mean(abs(exp(pred) - y[test]))
C <- as.vector(coef(cv.out, bestlam))
length(C[C != 0])
set.seed(35)
obj.escv <- escv.glmnet(x[train,], sqrt(y[train]))
obj <- Lasso(x[train,], log(y[train]), lambda = obj.escv$lambda.cv)
pred <- mypredict(obj, newx = x[test,])
mean(abs(exp(pred) - y[test]))
